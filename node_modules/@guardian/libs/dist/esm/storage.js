var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, privateMap, value) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to set private field on non-instance");
    }
    privateMap.set(receiver, value);
    return value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, privateMap) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to get private field on non-instance");
    }
    return privateMap.get(receiver);
};
var _storage, _local, _session, _a;
class StorageFactory {
    constructor(storage) {
        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/Private_class_fields
        _storage.set(this, void 0);
        try {
            const uid = new Date().toString();
            storage.setItem(uid, uid);
            const available = storage.getItem(uid) == uid;
            storage.removeItem(uid);
            if (available)
                __classPrivateFieldSet(this, _storage, storage);
        }
        catch (e) {
            // do nothing
        }
    }
    /**
     * Check whether storage is available.
     */
    isAvailable() {
        return Boolean(__classPrivateFieldGet(this, _storage));
    }
    /* eslint-disable
        @typescript-eslint/no-unsafe-assignment,
        @typescript-eslint/no-unsafe-return,
        @typescript-eslint/no-explicit-any
        --
        - we're using the `try` to handle anything bad happening
        - JSON.parse returns an `any`, we really are returning an `any`
    */
    /**
     * Retrieve an item from storage.
     *
     * @param key - the name of the item
     */
    get(key) {
        try {
            const { value, expires } = JSON.parse(__classPrivateFieldGet(this, _storage)?.getItem(key) ?? '');
            // is this item has passed its sell-by-date, remove it
            if (expires && new Date() > new Date(expires)) {
                this.remove(key);
                return null;
            }
            return value;
        }
        catch (e) {
            return null;
        }
    }
    /* eslint-enable
        @typescript-eslint/no-unsafe-assignment,
        @typescript-eslint/no-unsafe-return,
        @typescript-eslint/no-explicit-any
    */
    /**
     * Save a value to storage.
     *
     * @param key - the name of the item
     * @param value - the data to save
     * @param expires - optional date on which this data will expire
     */
    set(key, value, expires) {
        return __classPrivateFieldGet(this, _storage)?.setItem(key, JSON.stringify({
            value,
            expires,
        }));
    }
    /**
     * Remove an item from storage.
     *
     * @param key - the name of the item
     */
    remove(key) {
        return __classPrivateFieldGet(this, _storage)?.removeItem(key);
    }
    /**
     * Removes all items from storage.
     */
    clear() {
        return __classPrivateFieldGet(this, _storage)?.clear();
    }
    /**
     * Retrieve an item from storage in its raw state.
     *
     * @param key - the name of the item
     */
    getRaw(key) {
        return __classPrivateFieldGet(this, _storage)?.getItem(key) ?? null;
    }
    /**
     * Save a raw value to storage.
     *
     * @param key - the name of the item
     * @param value - the data to save
     */
    setRaw(key, value) {
        return __classPrivateFieldGet(this, _storage)?.setItem(key, value);
    }
}
_storage = new WeakMap();
/**
 * Manages using `localStorage` and `sessionStorage`.
 *
 * Has a few advantages over the native API, including
 * - failing gracefully if storage is not available
 * - you can save and retrieve any JSONable data
 *
 * All methods are available for both `localStorage` and `sessionStorage`.
 */
export const storage = new (_a = class {
        constructor() {
            _local.set(this, void 0);
            _session.set(this, void 0);
        }
        // creating the instance requires testing the native implementation
        // which is blocking. therefore, only create new instances of the factory
        // when it's accessed i.e. we know we're going to use it
        get local() {
            return (__classPrivateFieldSet(this, _local, __classPrivateFieldGet(this, _local) || new StorageFactory(localStorage)));
        }
        get session() {
            return (__classPrivateFieldSet(this, _session, __classPrivateFieldGet(this, _session) || new StorageFactory(sessionStorage)));
        }
    },
    _local = new WeakMap(),
    _session = new WeakMap(),
    _a)();
